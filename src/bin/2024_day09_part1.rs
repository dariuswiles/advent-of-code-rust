//! Advent of Code 2024 Day 09
//! https://adventofcode.com/2024/day/9
//!
//! Challenge part 1
//!
//! The input is a sequence of numbers that represent files and empty space stored on disk blocks.
//! The challenge requires the disk blocks to be "compacted" by rearranging them so all the used
//! blocks are contiguous at the start of the disk. A checksum is then generated by summing a value
//! calculated for each used block from the block's position and the id of the file it contains.

use std::fs;
use std::iter::zip;

const INPUT_FILENAME: &str = "2024_day09_input.txt";

type FileId = u16;

fn main() {
    let input = fs::read_to_string(INPUT_FILENAME).expect("Error reading input file");
    println!(
        "The checksum over all compacted files is {}",
        do_challenge(&input)
    );
}

/// Reads the input into a disk map, compacts the files in this disk map following the process in
/// the challenge, and generates a checksum that is then returned.
fn do_challenge(input: &str) -> u64 {
    let mut disk_map = parse_input(input);
    compact_disk_map(&mut disk_map);
    generate_checksum(&disk_map)
}

/// Returns a `Vec` where each element is a disk block. The input is a sequence of numbers where
/// the numbers at odd positions represent files that use that number of contiguous disk blocks. The
/// numbers at even blocks represent unused (i.e., empty) disk blocks that are that number of
/// contiguous disk blocks in size.
///
/// Based on the input, each block is either in use by a file or empty. Empty is represented as
/// `None`, and used as `Some(FileId)`, where `FileId` is a numeric value given to a file, with the
/// `first file in the input being 0, the second 1, etc.
///
/// # Panics
///
/// Panics if the input is malformed.
fn parse_input(input: &str) -> Vec<Option<FileId>> {
    let mut disk_map = Vec::new();

    let first_line: &str = input
        .lines()
        .collect::<Vec<_>>()
        .first()
        .expect("Error parsing input");

    for (index, c) in first_line.chars().enumerate() {
        let length =
            usize::try_from(c.to_digit(10).expect("Input must only consist of digits")).unwrap();

        let file_id = (index / 2) as FileId;

        if index % 2 == 0 {
            disk_map.append(&mut vec![Some(file_id); length]);
        } else {
            disk_map.append(&mut vec![None; length]);
        }
    }

    disk_map
}

/// Compacts the given `disk_map` by swapping used blocks at the end to empty blocks at the start
/// until all the used blocks are contiguous.
fn compact_disk_map(disk_map: &mut [Option<FileId>]) {
    let mut used_block_positions_rev = Vec::new();
    let empty_block_positions: Vec<_> = disk_map
        .iter()
        .enumerate()
        .filter_map(|(index, block)| match block {
            Some(_) => {
                used_block_positions_rev.push(index);
                None
            }
            None => Some(index),
        })
        .collect();

    used_block_positions_rev.reverse();
    let used_block_count = used_block_positions_rev.len();

    // Swap the last used block in the disk map to the first empty block and repeat until there is
    // a contiguous list of used blocks at the beginning of the disk map.

    let blocks_to_swap: Vec<_> = zip(empty_block_positions, used_block_positions_rev)
        .filter(|(empty, _)| empty < &used_block_count)
        .collect();

    for (empty, used) in blocks_to_swap {
        disk_map.swap(empty, used);
    }
}

/// Returns a checksum for the given `disk_map`. This is the sum from multiplying each non-empty
/// block's file id by its position in the `disk_map` (with the first block being 0).
fn generate_checksum(disk_map: &[Option<FileId>]) -> u64 {
    disk_map
        .iter()
        .enumerate()
        .map(|(position, block)| position as u64 * block.unwrap_or(0) as u64)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    const INPUT: &str = "2333133121414131402";

    #[test]
    fn test_parse_input_short() {
        let disk_map = parse_input("12345");

        assert_eq!(
            vec![
                Some(0),
                None,
                None,
                Some(1),
                Some(1),
                Some(1),
                None,
                None,
                None,
                None,
                Some(2),
                Some(2),
                Some(2),
                Some(2),
                Some(2),
            ],
            disk_map
        );
    }

    #[test]
    fn test_parse_input() {
        let disk_map = parse_input(INPUT);

        assert_eq!(
            vec![
                Some(0),
                Some(0),
                None,
                None,
                None,
                Some(1),
                Some(1),
                Some(1),
                None,
                None,
                None,
                Some(2),
                None,
                None,
                None,
                Some(3),
                Some(3),
                Some(3),
                None,
                Some(4),
                Some(4),
                None,
                Some(5),
                Some(5),
                Some(5),
                Some(5),
                None,
                Some(6),
                Some(6),
                Some(6),
                Some(6),
                None,
                Some(7),
                Some(7),
                Some(7),
                None,
                Some(8),
                Some(8),
                Some(8),
                Some(8),
                Some(9),
                Some(9),
            ],
            disk_map
        );
    }

    #[test]
    fn test_compact_disk_map_short() {
        let mut disk_map = parse_input("12345");
        compact_disk_map(&mut disk_map);

        assert_eq!(
            vec![
                Some(0),
                Some(2),
                Some(2),
                Some(1),
                Some(1),
                Some(1),
                Some(2),
                Some(2),
                Some(2),
                None,
                None,
                None,
                None,
                None,
                None,
            ],
            disk_map
        );
    }

    #[test]
    fn test_compact_disk_map() {
        let mut disk_map = parse_input(INPUT);
        compact_disk_map(&mut disk_map);

        assert_eq!(
            vec![
                Some(0),
                Some(0),
                Some(9),
                Some(9),
                Some(8),
                Some(1),
                Some(1),
                Some(1),
                Some(8),
                Some(8),
                Some(8),
                Some(2),
                Some(7),
                Some(7),
                Some(7),
                Some(3),
                Some(3),
                Some(3),
                Some(6),
                Some(4),
                Some(4),
                Some(6),
                Some(5),
                Some(5),
                Some(5),
                Some(5),
                Some(6),
                Some(6),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            ],
            disk_map
        );
    }

    #[test]
    fn test_do_challenge() {
        assert_eq!(1928, do_challenge(INPUT));
    }
}
