//! Advent of Code 2022 Day 08
//! https://adventofcode.com/2022/day/8
//!
//! Challenge part 2
//!
//! Reads an input file containing a grid of single digits, each digit representing the height of
//! a tree. Determines a "scenic score" for each tree, which is based on how many shorter trees
//! are in each direction vertically and horizontally (but not diagonally). The challenge answer is
//! the highest scenic score.

use std::fs;

type Height = i8;
type ScenicScore = u32;

const INPUT_FILENAME: &str = "2022_day08_input.txt";

/// Takes a string containing lines of tightly packed single digits and returns them as a
/// two-dimensional vector of integers.
///
/// # Panics
///
/// Panics if the input is malformed.
/// Panics if every row does not have the same number of columns.
fn parse_input(input: &str) -> Vec<Vec<Height>> {
    let mut grid: Vec<Vec<Height>> = Vec::new();

    for line in input.lines() {
        if !line.is_empty() {
            grid.push(
                line.chars()
                    .map(|c| c.to_digit(10).unwrap() as Height)
                    .collect(),
            );
        }
    }

    let num_columns: usize = grid[0].len();
    assert!(grid.iter().all(|row| row.len() == num_columns));

    grid
}

/// Returns a two-dimensional vector with the same dimensions as `tree_grid`. Each cell contains
/// the associated tree's "scenic score". See `score_tree()` for details.
fn score_trees(tree_grid: &[Vec<Height>]) -> Vec<Vec<ScenicScore>> {
    let num_rows = tree_grid.len();
    let num_columns = tree_grid[0].len();
    let mut scenic_score = Vec::new();

    // Initialize the scenic scores.
    for _ in 0..num_rows {
        scenic_score.push(vec![0; num_columns]);
    }

    // Skip the edges of the grid as the scenic scores will always be 0.
    #[allow(clippy::needless_range_loop)]
    for r in 1..num_rows - 1 {
        for c in 1..num_columns - 1 {
            scenic_score[r][c] = score_tree(tree_grid, r, c);
        }
    }

    scenic_score
}

/// Returns the scenic score of the tree at location `row`, `column` in `tree_grid`. This is
/// generated by multiplying a score for each of the four directions that is derived from the
/// number of trees that can be seen from the tree in the cell. Trees are counted until a tree of
/// equal or greater height is reached (and this tree is included in the total). Trees on the edge
/// of the grid will have one direction that scores 0, so their overall scenic score is 0.
fn score_tree(tree_grid: &[Vec<Height>], row: usize, column: usize) -> ScenicScore {
    let num_rows = tree_grid.len();
    let num_columns = tree_grid[0].len();
    let tree_house_height = tree_grid[row][column];
    let mut scenic_score = 1;

    if row == 0 || row >= num_rows || column == 0 || column >= num_columns {
        return 0;
    }

    // Right
    let mut length = 0;
    for c in column + 1..num_columns {
        let height = tree_grid[row][c];

        if height >= tree_house_height {
            length += 1;
            break;
        }
        length += 1;
    }
    scenic_score *= length;

    // Left
    let mut length = 0;
    for c in (0..column).rev() {
        let height = tree_grid[row][c];

        if height >= tree_house_height {
            length += 1;
            break;
        }
        length += 1;
    }
    scenic_score *= length;

    // Down
    let mut length = 0;
    #[allow(clippy::needless_range_loop)]
    for r in row + 1..num_rows {
        let height = tree_grid[r][column];

        if height >= tree_house_height {
            length += 1;
            break;
        }
        length += 1;
    }
    scenic_score *= length;

    // Up
    let mut length = 0;
    for r in (0..row).rev() {
        let height = tree_grid[r][column];

        if height >= tree_house_height {
            length += 1;
            break;
        }
        length += 1;
    }

    scenic_score * length
}

// Returns the number of visible trees in `visible_trees`.
fn challenge_answer(scenic_score: &[Vec<ScenicScore>]) -> ScenicScore {
    *scenic_score.iter().flatten().max().unwrap()
}

fn main() {
    let input = fs::read_to_string(INPUT_FILENAME).expect("Error reading input file");
    let tree_grid = parse_input(&input);
    let scenic_score = score_trees(&tree_grid);

    println!(
        "The highest scenic score is {}",
        challenge_answer(&scenic_score),
    );
}

// Test data based on examples on the challenge page.
#[cfg(test)]
mod tests {
    use super::*;

    const TEST_INPUT: &str = "\
30373
25512
65332
33549
35390
";

    #[test]
    fn test_parse_input() {
        let grid = parse_input(TEST_INPUT);

        #[rustfmt::skip]
        assert_eq!(grid,
            vec![
                vec![3, 0, 3, 7, 3,],
                vec![2, 5, 5, 1, 2,],
                vec![6, 5, 3, 3, 2,],
                vec![3, 3, 5, 4, 9,],
                vec![3, 5, 3, 9, 0,],
            ]
        );
    }

    #[test]
    #[should_panic]
    fn test_parse_input_unequal_lines() {
        #[rustfmt::skip]
        let _ = parse_input("303\n25512\n653");
    }

    #[test]
    fn test_score_trees() {
        let tree_grid = parse_input(TEST_INPUT);
        let scenic_score = score_trees(&tree_grid);

        #[rustfmt::skip]
        assert_eq!(scenic_score,
            vec![
                vec![0, 0, 0, 0, 0,],
                vec![0, 1, 4, 1, 0,],
                vec![0, 6, 1, 2, 0,],
                vec![0, 1, 8, 3, 0,],
                vec![0, 0, 0, 0, 0,],
            ]
        );
    }

    #[test]
    fn test_challenge_answer() {
        let tree_grid = parse_input(TEST_INPUT);
        let scenic_score = score_trees(&tree_grid);

        assert_eq!(challenge_answer(&scenic_score), 8);
    }
}
