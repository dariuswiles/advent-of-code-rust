//! Advent of Code 2024 Day 01
//! https://adventofcode.com/2024/day/1
//!
//! Challenge part 2
//!
//! The input consists of two columns of numbers. Part 2 of the challenge is to determine which
//! numbers in the left column also appear in the right column. For each number that does, its
//! value is multiplied by the number of times it appears in the left column and then multiplied
//! by the number of times it appears in the right column. The result is the challenge answer.

use std::fs;
use std::collections::HashMap;

const INPUT_FILENAME: &str = "2024_day01_input.txt";

fn main() {
    let input = fs::read_to_string(INPUT_FILENAME).expect("Error reading input file");
    println!(
        "The total of all similarity scores is {}",
        do_challenge(&input)
    );
}

/// Parses the two columns of numbers in the input. Returns the challenge answer which is the
/// difference between the smallest number in the left column and the smallest number in the
/// right column, added to the second smallest numbers, etc.
fn do_challenge(input: &str) -> u32 {
    let (left, right) = parse_input(input);
    calculate_similarity_scores(&left, &right)
}

/// Reads the input, which is expected to consist of one pair of integers on each line. Returns
/// the first column of integers in `left` and the second column in `right`.
///
/// # Panics
///
/// Panics if the input is malformed.
fn parse_input(input: &str) -> (Vec<u32>, Vec<u32>) {
    let mut left = Vec::new();
    let mut right = Vec::new();

    for line in input.lines() {
        if line.is_empty() {
            continue;
        }

        let nums: Vec<&str> = line.split(' ').filter(|token| token != &"").collect();
        assert_eq!(nums.len(), 2, "Each line of input must contain exactly two numbers");

        left.push(nums[0].parse::<u32>().unwrap());
        right.push(nums[1].parse::<u32>().unwrap());
    }

    (left, right)
}


/// Calculates the total "similarity score" defined by the challenge. This is generated by taking
/// each number that appears in the left column and multiplying its value by the number of times it
/// appears in the left column and multipling this with the number of times it appears in the right
/// column.
fn calculate_similarity_scores(left: &Vec<u32>, right: &Vec<u32>) -> u32 {
    let left_frequencies = create_frequency_map(left);
    let right_frequencies = create_frequency_map(right);

    let mut total = 0;

    for l in left_frequencies.keys() {
        total += *l * left_frequencies.get(l).unwrap() * right_frequencies.get(l).unwrap_or(&0);
    }

    total
}

/// Creates a `HashMap` frequency mapping which maps the numbers that appear in the `Vec` passed
/// to the number of occurrences of that number.
fn create_frequency_map(nums: &Vec<u32>) -> HashMap<&u32, u32> {
    let mut freq_map = HashMap::new();

    for n in nums {
        match freq_map.get_mut(&n) {
            Some(count) => {
                *count += 1;
            }
            None => {
                freq_map.insert(n, 1);
            }
        }
    }

    freq_map
}

// Test data based on examples on the challenge page.
#[cfg(test)]
mod tests {
    use super::*;

    const TEST_INPUT: &str = "\
3   4
4   3
2   5
1   3
3   9
3   3
";

    #[test]
    fn test_parse_input() {
        assert_eq!(
            parse_input(&TEST_INPUT),
            (vec![3, 4, 2, 1, 3, 3], vec![4, 3, 5, 3, 9, 3])
        );
    }

    #[test]
    fn test_create_frequency_map() {
        let left = vec![3, 4, 2, 1, 3, 3];
        let result0 = create_frequency_map(&left);

        assert_eq!(result0.get(&0), None);
        assert_eq!(result0.get(&1), Some(&1));
        assert_eq!(result0.get(&2), Some(&1));
        assert_eq!(result0.get(&3), Some(&3));
        assert_eq!(result0.get(&4), Some(&1));

        let right = vec![4, 3, 5, 3, 9, 3];
        let result1 = create_frequency_map(&right);

        assert_eq!(result1.get(&0), None);
        assert_eq!(result1.get(&1), None);
        assert_eq!(result1.get(&2), None);
        assert_eq!(result1.get(&3), Some(&3));
        assert_eq!(result1.get(&4), Some(&1));
        assert_eq!(result1.get(&5), Some(&1));
        assert_eq!(result1.get(&9), Some(&1));
    }

    #[test]
    fn test_calculate_similarity_scores() {
        let left = vec![3, 4, 2, 1, 3, 3];
        let right = vec![4, 3, 5, 3, 9, 3];

        assert_eq!(calculate_similarity_scores(&left, &right), 31);
    }

    #[test]
    fn test_do_challenge() {
        assert_eq!(do_challenge(&TEST_INPUT), 31);
    }
}
