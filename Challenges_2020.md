# 2020 Challenges

Day | Challenge
:---:|---
01 | The input file is a list of unsigned integers. The challenge is to find the two (part 1) or three (part 2) integers that add up to a given number.
02 | Each line of the input file consists of a rule defining where a given character can appear in the given string and the challenge is to find the strings that meet their rule. The two parts interpret the rule strings in different ways.
03 | The input file is a 2D map and the challenge is to determine the number of obstacles encountered while traversing the map in a given pattern.
04 | Part 1 verifies the presence of certain field/data pairs in the input file. Part 2 extends this by validating the data.
05 | Each line of the input file represents a seat. Part 1 requires the highest `seat ID` in the list to be determined. Part 2 requires the `seat ID` of the seat missing from the list.
06 | The input file contains groups of lines where each line contains alphabetic characters. Part 1 requires returning the number of unique occurrences of individual characters within each group. Part 2 requires the number of occurrences of characters appearing on every line in each group.
07 | The input file comprises rules that define a style of bag and the number and style of bags that it must contain, creating a nested structure. Part 1 asks how many different types of bags a given style of bag can be in. Part 2 asks how many bags are contained in a given style of bag.
08 | The challenge defines a simple, low level programming language. Part 1 asks for the point at which an instruction is executed a second time, indicating the beginning of an infinite loop. Part 2 requires modifying the program to prevent an infinite loop, and determining the output it gives when run to completion.
09 | The input file is a list of integers. Part 1 asks for the first integer that is not the sum of any two integers in a given sized set of previous integers. Part 2 requires a contiguous set of integers to be found in the list that sum to a given number.
10 | The input file is a set of integers. Part 1 asks for an analysis of the differences between integers close to each other in value. Part 2 
11 | The challenge is worded in terms of passengers taking or leaving seats in a seating plan, but it shares similarities with a game of life simulation. Part 1 applies rules repeatedly until the seating plan stabilizes. Part 2 changes the rules to consider seats further away than just the 8 adjacent seats.
12 | Move the position and orientation of a ship based on commands in the input file. Part 1 requires the Manhattan distance to its final position. Part 2 adds a waypoint and modifies the meaning of some commands.
13 | Given the current time and a bus timetable, part 1 asks  for the time of the next bus. Part 2 expands the puzzle to include the timing of multiple buses.  <br />⏳ The solution for part 2 takes 90 minutes to complete when built with --release.
14 | The input file consists of data to load into simulated memory, accompanied by bitmasks that modify the data while being loaded. Part 1 asks for the sum of the resultant memory. Part 2 modifies the way bitmasks are applied.
15 | The challenge is based on extending a sequence of numbers from a given starting set, following a set of rules. Part 1 asks for the 2020th number in the sequence and part 2 the 30000000th number. My code for part 1 would take unacceptably long to determine the answer for part 2, so a lot is rewritten.
16 | The input data defines a set of fields and gives their associated valid ranges. It includes tickets with their associated data values, but there is no mapping between these values and fields. The answer to part 1 is based on identifying which tickets in the input data have data values that are outside the range of every field. The answer for part 2 is found by discarding these invalid tickets and determining the mapping between data values and fields.
17 | The challenge is similar to a game of life simulation, but in 3 dimensions. Part 1 applies the given rules 6 times to get a result. Part 2 expands the simulation to 4 dimensions.
18 | Part 1 evaluates math expressions using an equal order of precedence for all operators, allowing them to be evaluated left-to-right. Part 2 is similar except one operator has higher precedence.
19 | The input data consists of a set of rules that define whether a string is valid, and a set of strings. Part 1 validates which strings are valid according to the rules. Part 2 adds recursive rules.
20 | Flip and rotate the square tiles in the input data so that the patterns on their edges align with adjacent tiles. Part 1 checks the correctness of the result. Part 2 searches for a 2 dimensional image in the result of part 1, removes all occurrences including flipped and rotated versions, and checks the remaining data.
21 | The input data lists food ingredients and associated allergen information. Part 1 asks for ingredients which are free from all allergens. Part 2 asks for the mapping between ingredients and allergens.
22 | The challenge is a card game, and the input file contains the cards held by two players. Part 1 asks who wins the game and their score. Part 2 adds more complex game rules, including recursion.
23 | The challenge describes a game involving moving cups according to a set of rules. Part 1 requires modeling 100 cups for 100 moves. Part 2 is the same, except for modeling 1,000,000 cups for 10,000,000 moves.<br />⏳ My code is largely the same for both parts, but part 2 takes 2 hours 10 minutes to either run the tests or find the answer to the challenge, so would benefit  from looking for optimizations. The speed is based on using the --release option for the fastest code.
24 | The challenge models a grid of hexagonal tiles. The input data toggles the state of tiles, and part 1 asks for the number of tiles that differ from their starting state when all changes have been made. Part 2 performs multiple rounds of tile toggling.
25 | The challenge is to brute force the shared encryption key for a simple encryption protocol that shares some characteristics with a Diffie-Hellman key exchange.

